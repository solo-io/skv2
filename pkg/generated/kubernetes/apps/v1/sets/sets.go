// Code generated by skv2. DO NOT EDIT.

package v1sets

import (
	. "k8s.io/api/apps/v1"

	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/sets"
)

type DeploymentSet interface {
	Keys() sets.String
	List() []*Deployment
	Map() map[string]*Deployment
	Insert(deployment ...*Deployment)
	Equal(deploymentSet DeploymentSet) bool
	Has(deployment *Deployment) bool
	Delete(deployment *Deployment)
	Union(set DeploymentSet) DeploymentSet
	Difference(set DeploymentSet) DeploymentSet
	Intersection(set DeploymentSet) DeploymentSet
}

func makeGenericDeploymentSet(deploymentList []*Deployment) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range deploymentList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type deploymentSet struct {
	set sksets.ResourceSet
}

func NewDeploymentSet(deploymentList ...*Deployment) DeploymentSet {
	return &deploymentSet{set: makeGenericDeploymentSet(deploymentList)}
}

func (s deploymentSet) Keys() sets.String {
	return s.set.Keys()
}

func (s deploymentSet) List() []*Deployment {
	var deploymentList []*Deployment
	for _, obj := range s.set.List() {
		deploymentList = append(deploymentList, obj.(*Deployment))
	}
	return deploymentList
}

func (s deploymentSet) Map() map[string]*Deployment {
	newMap := map[string]*Deployment{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Deployment)
	}
	return newMap
}

func (s deploymentSet) Insert(
	deploymentList ...*Deployment,
) {
	for _, obj := range deploymentList {
		s.set.Insert(obj)
	}
}

func (s deploymentSet) Has(deployment *Deployment) bool {
	return s.set.Has(deployment)
}

func (s deploymentSet) Equal(
	deploymentSet DeploymentSet,
) bool {
	return s.set.Equal(makeGenericDeploymentSet(deploymentSet.List()))
}

func (s deploymentSet) Delete(Deployment *Deployment) {
	s.set.Delete(Deployment)
}

func (s deploymentSet) Union(set DeploymentSet) DeploymentSet {
	return NewDeploymentSet(append(s.List(), set.List()...)...)
}

func (s deploymentSet) Difference(set DeploymentSet) DeploymentSet {
	newSet := s.set.Difference(makeGenericDeploymentSet(set.List()))
	return deploymentSet{set: newSet}
}

func (s deploymentSet) Intersection(set DeploymentSet) DeploymentSet {
	newSet := s.set.Intersection(makeGenericDeploymentSet(set.List()))
	var deploymentList []*Deployment
	for _, obj := range newSet.List() {
		deploymentList = append(deploymentList, obj.(*Deployment))
	}
	return NewDeploymentSet(deploymentList...)
}

type ReplicaSetSet interface {
	Keys() sets.String
	List() []*ReplicaSet
	Map() map[string]*ReplicaSet
	Insert(replicaSet ...*ReplicaSet)
	Equal(replicaSetSet ReplicaSetSet) bool
	Has(replicaSet *ReplicaSet) bool
	Delete(replicaSet *ReplicaSet)
	Union(set ReplicaSetSet) ReplicaSetSet
	Difference(set ReplicaSetSet) ReplicaSetSet
	Intersection(set ReplicaSetSet) ReplicaSetSet
}

func makeGenericReplicaSetSet(replicaSetList []*ReplicaSet) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range replicaSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type replicaSetSet struct {
	set sksets.ResourceSet
}

func NewReplicaSetSet(replicaSetList ...*ReplicaSet) ReplicaSetSet {
	return &replicaSetSet{set: makeGenericReplicaSetSet(replicaSetList)}
}

func (s replicaSetSet) Keys() sets.String {
	return s.set.Keys()
}

func (s replicaSetSet) List() []*ReplicaSet {
	var replicaSetList []*ReplicaSet
	for _, obj := range s.set.List() {
		replicaSetList = append(replicaSetList, obj.(*ReplicaSet))
	}
	return replicaSetList
}

func (s replicaSetSet) Map() map[string]*ReplicaSet {
	newMap := map[string]*ReplicaSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*ReplicaSet)
	}
	return newMap
}

func (s replicaSetSet) Insert(
	replicaSetList ...*ReplicaSet,
) {
	for _, obj := range replicaSetList {
		s.set.Insert(obj)
	}
}

func (s replicaSetSet) Has(replicaSet *ReplicaSet) bool {
	return s.set.Has(replicaSet)
}

func (s replicaSetSet) Equal(
	replicaSetSet ReplicaSetSet,
) bool {
	return s.set.Equal(makeGenericReplicaSetSet(replicaSetSet.List()))
}

func (s replicaSetSet) Delete(ReplicaSet *ReplicaSet) {
	s.set.Delete(ReplicaSet)
}

func (s replicaSetSet) Union(set ReplicaSetSet) ReplicaSetSet {
	return NewReplicaSetSet(append(s.List(), set.List()...)...)
}

func (s replicaSetSet) Difference(set ReplicaSetSet) ReplicaSetSet {
	newSet := s.set.Difference(makeGenericReplicaSetSet(set.List()))
	return replicaSetSet{set: newSet}
}

func (s replicaSetSet) Intersection(set ReplicaSetSet) ReplicaSetSet {
	newSet := s.set.Intersection(makeGenericReplicaSetSet(set.List()))
	var replicaSetList []*ReplicaSet
	for _, obj := range newSet.List() {
		replicaSetList = append(replicaSetList, obj.(*ReplicaSet))
	}
	return NewReplicaSetSet(replicaSetList...)
}

type DaemonSetSet interface {
	Keys() sets.String
	List() []*DaemonSet
	Map() map[string]*DaemonSet
	Insert(daemonSet ...*DaemonSet)
	Equal(daemonSetSet DaemonSetSet) bool
	Has(daemonSet *DaemonSet) bool
	Delete(daemonSet *DaemonSet)
	Union(set DaemonSetSet) DaemonSetSet
	Difference(set DaemonSetSet) DaemonSetSet
	Intersection(set DaemonSetSet) DaemonSetSet
}

func makeGenericDaemonSetSet(daemonSetList []*DaemonSet) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range daemonSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type daemonSetSet struct {
	set sksets.ResourceSet
}

func NewDaemonSetSet(daemonSetList ...*DaemonSet) DaemonSetSet {
	return &daemonSetSet{set: makeGenericDaemonSetSet(daemonSetList)}
}

func (s daemonSetSet) Keys() sets.String {
	return s.set.Keys()
}

func (s daemonSetSet) List() []*DaemonSet {
	var daemonSetList []*DaemonSet
	for _, obj := range s.set.List() {
		daemonSetList = append(daemonSetList, obj.(*DaemonSet))
	}
	return daemonSetList
}

func (s daemonSetSet) Map() map[string]*DaemonSet {
	newMap := map[string]*DaemonSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*DaemonSet)
	}
	return newMap
}

func (s daemonSetSet) Insert(
	daemonSetList ...*DaemonSet,
) {
	for _, obj := range daemonSetList {
		s.set.Insert(obj)
	}
}

func (s daemonSetSet) Has(daemonSet *DaemonSet) bool {
	return s.set.Has(daemonSet)
}

func (s daemonSetSet) Equal(
	daemonSetSet DaemonSetSet,
) bool {
	return s.set.Equal(makeGenericDaemonSetSet(daemonSetSet.List()))
}

func (s daemonSetSet) Delete(DaemonSet *DaemonSet) {
	s.set.Delete(DaemonSet)
}

func (s daemonSetSet) Union(set DaemonSetSet) DaemonSetSet {
	return NewDaemonSetSet(append(s.List(), set.List()...)...)
}

func (s daemonSetSet) Difference(set DaemonSetSet) DaemonSetSet {
	newSet := s.set.Difference(makeGenericDaemonSetSet(set.List()))
	return daemonSetSet{set: newSet}
}

func (s daemonSetSet) Intersection(set DaemonSetSet) DaemonSetSet {
	newSet := s.set.Intersection(makeGenericDaemonSetSet(set.List()))
	var daemonSetList []*DaemonSet
	for _, obj := range newSet.List() {
		daemonSetList = append(daemonSetList, obj.(*DaemonSet))
	}
	return NewDaemonSetSet(daemonSetList...)
}
