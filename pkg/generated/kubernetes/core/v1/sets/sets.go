// Code generated by skv2. DO NOT EDIT.

package v1sets

import (
	. "k8s.io/api/core/v1"

	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/sets"
)

type SecretSet interface {
	Keys() sets.String
	List() []*Secret
	Map() map[string]*Secret
	Insert(secret ...*Secret)
	Equal(secretSet SecretSet) bool
	Has(secret *Secret) bool
	Delete(secret *Secret)
	Union(set SecretSet) SecretSet
	Difference(set SecretSet) SecretSet
	Intersection(set SecretSet) SecretSet
}

func makeGenericSecretSet(secretList []*Secret) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range secretList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type secretSet struct {
	set sksets.ResourceSet
}

func NewSecretSet(secretList ...*Secret) SecretSet {
	return &secretSet{set: makeGenericSecretSet(secretList)}
}

func (s secretSet) Keys() sets.String {
	return s.set.Keys()
}

func (s secretSet) List() []*Secret {
	var secretList []*Secret
	for _, obj := range s.set.List() {
		secretList = append(secretList, obj.(*Secret))
	}
	return secretList
}

func (s secretSet) Map() map[string]*Secret {
	newMap := map[string]*Secret{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Secret)
	}
	return newMap
}

func (s secretSet) Insert(
	secretList ...*Secret,
) {
	for _, obj := range secretList {
		s.set.Insert(obj)
	}
}

func (s secretSet) Has(secret *Secret) bool {
	return s.set.Has(secret)
}

func (s secretSet) Equal(
	secretSet SecretSet,
) bool {
	return s.set.Equal(makeGenericSecretSet(secretSet.List()))
}

func (s secretSet) Delete(Secret *Secret) {
	s.set.Delete(Secret)
}

func (s secretSet) Union(set SecretSet) SecretSet {
	return NewSecretSet(append(s.List(), set.List()...)...)
}

func (s secretSet) Difference(set SecretSet) SecretSet {
	newSet := s.set.Difference(makeGenericSecretSet(set.List()))
	return secretSet{set: newSet}
}

func (s secretSet) Intersection(set SecretSet) SecretSet {
	newSet := s.set.Intersection(makeGenericSecretSet(set.List()))
	var secretList []*Secret
	for _, obj := range newSet.List() {
		secretList = append(secretList, obj.(*Secret))
	}
	return NewSecretSet(secretList...)
}

type ServiceAccountSet interface {
	Keys() sets.String
	List() []*ServiceAccount
	Map() map[string]*ServiceAccount
	Insert(serviceAccount ...*ServiceAccount)
	Equal(serviceAccountSet ServiceAccountSet) bool
	Has(serviceAccount *ServiceAccount) bool
	Delete(serviceAccount *ServiceAccount)
	Union(set ServiceAccountSet) ServiceAccountSet
	Difference(set ServiceAccountSet) ServiceAccountSet
	Intersection(set ServiceAccountSet) ServiceAccountSet
}

func makeGenericServiceAccountSet(serviceAccountList []*ServiceAccount) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range serviceAccountList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceAccountSet struct {
	set sksets.ResourceSet
}

func NewServiceAccountSet(serviceAccountList ...*ServiceAccount) ServiceAccountSet {
	return &serviceAccountSet{set: makeGenericServiceAccountSet(serviceAccountList)}
}

func (s serviceAccountSet) Keys() sets.String {
	return s.set.Keys()
}

func (s serviceAccountSet) List() []*ServiceAccount {
	var serviceAccountList []*ServiceAccount
	for _, obj := range s.set.List() {
		serviceAccountList = append(serviceAccountList, obj.(*ServiceAccount))
	}
	return serviceAccountList
}

func (s serviceAccountSet) Map() map[string]*ServiceAccount {
	newMap := map[string]*ServiceAccount{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*ServiceAccount)
	}
	return newMap
}

func (s serviceAccountSet) Insert(
	serviceAccountList ...*ServiceAccount,
) {
	for _, obj := range serviceAccountList {
		s.set.Insert(obj)
	}
}

func (s serviceAccountSet) Has(serviceAccount *ServiceAccount) bool {
	return s.set.Has(serviceAccount)
}

func (s serviceAccountSet) Equal(
	serviceAccountSet ServiceAccountSet,
) bool {
	return s.set.Equal(makeGenericServiceAccountSet(serviceAccountSet.List()))
}

func (s serviceAccountSet) Delete(ServiceAccount *ServiceAccount) {
	s.set.Delete(ServiceAccount)
}

func (s serviceAccountSet) Union(set ServiceAccountSet) ServiceAccountSet {
	return NewServiceAccountSet(append(s.List(), set.List()...)...)
}

func (s serviceAccountSet) Difference(set ServiceAccountSet) ServiceAccountSet {
	newSet := s.set.Difference(makeGenericServiceAccountSet(set.List()))
	return serviceAccountSet{set: newSet}
}

func (s serviceAccountSet) Intersection(set ServiceAccountSet) ServiceAccountSet {
	newSet := s.set.Intersection(makeGenericServiceAccountSet(set.List()))
	var serviceAccountList []*ServiceAccount
	for _, obj := range newSet.List() {
		serviceAccountList = append(serviceAccountList, obj.(*ServiceAccount))
	}
	return NewServiceAccountSet(serviceAccountList...)
}

type ConfigMapSet interface {
	Keys() sets.String
	List() []*ConfigMap
	Map() map[string]*ConfigMap
	Insert(configMap ...*ConfigMap)
	Equal(configMapSet ConfigMapSet) bool
	Has(configMap *ConfigMap) bool
	Delete(configMap *ConfigMap)
	Union(set ConfigMapSet) ConfigMapSet
	Difference(set ConfigMapSet) ConfigMapSet
	Intersection(set ConfigMapSet) ConfigMapSet
}

func makeGenericConfigMapSet(configMapList []*ConfigMap) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range configMapList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type configMapSet struct {
	set sksets.ResourceSet
}

func NewConfigMapSet(configMapList ...*ConfigMap) ConfigMapSet {
	return &configMapSet{set: makeGenericConfigMapSet(configMapList)}
}

func (s configMapSet) Keys() sets.String {
	return s.set.Keys()
}

func (s configMapSet) List() []*ConfigMap {
	var configMapList []*ConfigMap
	for _, obj := range s.set.List() {
		configMapList = append(configMapList, obj.(*ConfigMap))
	}
	return configMapList
}

func (s configMapSet) Map() map[string]*ConfigMap {
	newMap := map[string]*ConfigMap{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*ConfigMap)
	}
	return newMap
}

func (s configMapSet) Insert(
	configMapList ...*ConfigMap,
) {
	for _, obj := range configMapList {
		s.set.Insert(obj)
	}
}

func (s configMapSet) Has(configMap *ConfigMap) bool {
	return s.set.Has(configMap)
}

func (s configMapSet) Equal(
	configMapSet ConfigMapSet,
) bool {
	return s.set.Equal(makeGenericConfigMapSet(configMapSet.List()))
}

func (s configMapSet) Delete(ConfigMap *ConfigMap) {
	s.set.Delete(ConfigMap)
}

func (s configMapSet) Union(set ConfigMapSet) ConfigMapSet {
	return NewConfigMapSet(append(s.List(), set.List()...)...)
}

func (s configMapSet) Difference(set ConfigMapSet) ConfigMapSet {
	newSet := s.set.Difference(makeGenericConfigMapSet(set.List()))
	return configMapSet{set: newSet}
}

func (s configMapSet) Intersection(set ConfigMapSet) ConfigMapSet {
	newSet := s.set.Intersection(makeGenericConfigMapSet(set.List()))
	var configMapList []*ConfigMap
	for _, obj := range newSet.List() {
		configMapList = append(configMapList, obj.(*ConfigMap))
	}
	return NewConfigMapSet(configMapList...)
}

type ServiceSet interface {
	Keys() sets.String
	List() []*Service
	Map() map[string]*Service
	Insert(service ...*Service)
	Equal(serviceSet ServiceSet) bool
	Has(service *Service) bool
	Delete(service *Service)
	Union(set ServiceSet) ServiceSet
	Difference(set ServiceSet) ServiceSet
	Intersection(set ServiceSet) ServiceSet
}

func makeGenericServiceSet(serviceList []*Service) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range serviceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceSet struct {
	set sksets.ResourceSet
}

func NewServiceSet(serviceList ...*Service) ServiceSet {
	return &serviceSet{set: makeGenericServiceSet(serviceList)}
}

func (s serviceSet) Keys() sets.String {
	return s.set.Keys()
}

func (s serviceSet) List() []*Service {
	var serviceList []*Service
	for _, obj := range s.set.List() {
		serviceList = append(serviceList, obj.(*Service))
	}
	return serviceList
}

func (s serviceSet) Map() map[string]*Service {
	newMap := map[string]*Service{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Service)
	}
	return newMap
}

func (s serviceSet) Insert(
	serviceList ...*Service,
) {
	for _, obj := range serviceList {
		s.set.Insert(obj)
	}
}

func (s serviceSet) Has(service *Service) bool {
	return s.set.Has(service)
}

func (s serviceSet) Equal(
	serviceSet ServiceSet,
) bool {
	return s.set.Equal(makeGenericServiceSet(serviceSet.List()))
}

func (s serviceSet) Delete(Service *Service) {
	s.set.Delete(Service)
}

func (s serviceSet) Union(set ServiceSet) ServiceSet {
	return NewServiceSet(append(s.List(), set.List()...)...)
}

func (s serviceSet) Difference(set ServiceSet) ServiceSet {
	newSet := s.set.Difference(makeGenericServiceSet(set.List()))
	return serviceSet{set: newSet}
}

func (s serviceSet) Intersection(set ServiceSet) ServiceSet {
	newSet := s.set.Intersection(makeGenericServiceSet(set.List()))
	var serviceList []*Service
	for _, obj := range newSet.List() {
		serviceList = append(serviceList, obj.(*Service))
	}
	return NewServiceSet(serviceList...)
}

type PodSet interface {
	Keys() sets.String
	List() []*Pod
	Map() map[string]*Pod
	Insert(pod ...*Pod)
	Equal(podSet PodSet) bool
	Has(pod *Pod) bool
	Delete(pod *Pod)
	Union(set PodSet) PodSet
	Difference(set PodSet) PodSet
	Intersection(set PodSet) PodSet
}

func makeGenericPodSet(podList []*Pod) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range podList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type podSet struct {
	set sksets.ResourceSet
}

func NewPodSet(podList ...*Pod) PodSet {
	return &podSet{set: makeGenericPodSet(podList)}
}

func (s podSet) Keys() sets.String {
	return s.set.Keys()
}

func (s podSet) List() []*Pod {
	var podList []*Pod
	for _, obj := range s.set.List() {
		podList = append(podList, obj.(*Pod))
	}
	return podList
}

func (s podSet) Map() map[string]*Pod {
	newMap := map[string]*Pod{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Pod)
	}
	return newMap
}

func (s podSet) Insert(
	podList ...*Pod,
) {
	for _, obj := range podList {
		s.set.Insert(obj)
	}
}

func (s podSet) Has(pod *Pod) bool {
	return s.set.Has(pod)
}

func (s podSet) Equal(
	podSet PodSet,
) bool {
	return s.set.Equal(makeGenericPodSet(podSet.List()))
}

func (s podSet) Delete(Pod *Pod) {
	s.set.Delete(Pod)
}

func (s podSet) Union(set PodSet) PodSet {
	return NewPodSet(append(s.List(), set.List()...)...)
}

func (s podSet) Difference(set PodSet) PodSet {
	newSet := s.set.Difference(makeGenericPodSet(set.List()))
	return podSet{set: newSet}
}

func (s podSet) Intersection(set PodSet) PodSet {
	newSet := s.set.Intersection(makeGenericPodSet(set.List()))
	var podList []*Pod
	for _, obj := range newSet.List() {
		podList = append(podList, obj.(*Pod))
	}
	return NewPodSet(podList...)
}

type NamespaceSet interface {
	Keys() sets.String
	List() []*Namespace
	Map() map[string]*Namespace
	Insert(namespace ...*Namespace)
	Equal(namespaceSet NamespaceSet) bool
	Has(namespace *Namespace) bool
	Delete(namespace *Namespace)
	Union(set NamespaceSet) NamespaceSet
	Difference(set NamespaceSet) NamespaceSet
	Intersection(set NamespaceSet) NamespaceSet
}

func makeGenericNamespaceSet(namespaceList []*Namespace) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range namespaceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type namespaceSet struct {
	set sksets.ResourceSet
}

func NewNamespaceSet(namespaceList ...*Namespace) NamespaceSet {
	return &namespaceSet{set: makeGenericNamespaceSet(namespaceList)}
}

func (s namespaceSet) Keys() sets.String {
	return s.set.Keys()
}

func (s namespaceSet) List() []*Namespace {
	var namespaceList []*Namespace
	for _, obj := range s.set.List() {
		namespaceList = append(namespaceList, obj.(*Namespace))
	}
	return namespaceList
}

func (s namespaceSet) Map() map[string]*Namespace {
	newMap := map[string]*Namespace{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Namespace)
	}
	return newMap
}

func (s namespaceSet) Insert(
	namespaceList ...*Namespace,
) {
	for _, obj := range namespaceList {
		s.set.Insert(obj)
	}
}

func (s namespaceSet) Has(namespace *Namespace) bool {
	return s.set.Has(namespace)
}

func (s namespaceSet) Equal(
	namespaceSet NamespaceSet,
) bool {
	return s.set.Equal(makeGenericNamespaceSet(namespaceSet.List()))
}

func (s namespaceSet) Delete(Namespace *Namespace) {
	s.set.Delete(Namespace)
}

func (s namespaceSet) Union(set NamespaceSet) NamespaceSet {
	return NewNamespaceSet(append(s.List(), set.List()...)...)
}

func (s namespaceSet) Difference(set NamespaceSet) NamespaceSet {
	newSet := s.set.Difference(makeGenericNamespaceSet(set.List()))
	return namespaceSet{set: newSet}
}

func (s namespaceSet) Intersection(set NamespaceSet) NamespaceSet {
	newSet := s.set.Intersection(makeGenericNamespaceSet(set.List()))
	var namespaceList []*Namespace
	for _, obj := range newSet.List() {
		namespaceList = append(namespaceList, obj.(*Namespace))
	}
	return NewNamespaceSet(namespaceList...)
}

type NodeSet interface {
	Keys() sets.String
	List() []*Node
	Map() map[string]*Node
	Insert(node ...*Node)
	Equal(nodeSet NodeSet) bool
	Has(node *Node) bool
	Delete(node *Node)
	Union(set NodeSet) NodeSet
	Difference(set NodeSet) NodeSet
	Intersection(set NodeSet) NodeSet
}

func makeGenericNodeSet(nodeList []*Node) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range nodeList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type nodeSet struct {
	set sksets.ResourceSet
}

func NewNodeSet(nodeList ...*Node) NodeSet {
	return &nodeSet{set: makeGenericNodeSet(nodeList)}
}

func (s nodeSet) Keys() sets.String {
	return s.set.Keys()
}

func (s nodeSet) List() []*Node {
	var nodeList []*Node
	for _, obj := range s.set.List() {
		nodeList = append(nodeList, obj.(*Node))
	}
	return nodeList
}

func (s nodeSet) Map() map[string]*Node {
	newMap := map[string]*Node{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Node)
	}
	return newMap
}

func (s nodeSet) Insert(
	nodeList ...*Node,
) {
	for _, obj := range nodeList {
		s.set.Insert(obj)
	}
}

func (s nodeSet) Has(node *Node) bool {
	return s.set.Has(node)
}

func (s nodeSet) Equal(
	nodeSet NodeSet,
) bool {
	return s.set.Equal(makeGenericNodeSet(nodeSet.List()))
}

func (s nodeSet) Delete(Node *Node) {
	s.set.Delete(Node)
}

func (s nodeSet) Union(set NodeSet) NodeSet {
	return NewNodeSet(append(s.List(), set.List()...)...)
}

func (s nodeSet) Difference(set NodeSet) NodeSet {
	newSet := s.set.Difference(makeGenericNodeSet(set.List()))
	return nodeSet{set: newSet}
}

func (s nodeSet) Intersection(set NodeSet) NodeSet {
	newSet := s.set.Intersection(makeGenericNodeSet(set.List()))
	var nodeList []*Node
	for _, obj := range newSet.List() {
		nodeList = append(nodeList, obj.(*Node))
	}
	return NewNodeSet(nodeList...)
}
