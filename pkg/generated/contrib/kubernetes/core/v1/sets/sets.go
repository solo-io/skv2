// Code generated by skv2. DO NOT EDIT.

package v1

import (
	. "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/sets"
)

// k8s resources are uniquely identified by their name and namespace
func key(objectMeta v1.ObjectMeta) string {
	return objectMeta.GetName() + "." + objectMeta.GetNamespace()
}

type ServiceSet interface {
	Keys() sets.String
	List() []*Service
	Map() map[string]*Service
	Insert(service ...*Service)
	Equal(serviceSet ServiceSet) bool
	Has(service *Service) bool
	Delete(service *Service)
	Union(set ServiceSet) ServiceSet
	Difference(set ServiceSet) ServiceSet
	Intersection(set ServiceSet) ServiceSet
}

type serviceSet struct {
	set     sets.String
	mapping map[string]*Service
}

func NewServiceSet(Services ...*Service) ServiceSet {
	set := sets.NewString()
	mapping := map[string]*Service{}
	for _, Service := range Services {
		key := key(Service.ObjectMeta)
		set.Insert(key)
		mapping[key] = Service
	}
	return &serviceSet{set: set, mapping: mapping}
}

func (s serviceSet) Keys() sets.String {
	return sets.NewString(s.set.List()...)
}

func (s serviceSet) List() []*Service {
	var Services []*Service
	for _, key := range s.set.List() {
		Services = append(Services, s.mapping[key])
	}
	return Services
}

func (s serviceSet) Map() map[string]*Service {
	newMap := map[string]*Service{}
	for k, v := range s.mapping {
		newMap[k] = v
	}
	return newMap
}

func (s serviceSet) Insert(
	Services ...*Service,
) {
	for _, Service := range Services {
		key := key(Service.ObjectMeta)
		s.mapping[key] = Service
		s.set.Insert(key)
	}
}

func (s serviceSet) Has(Service *Service) bool {
	return s.set.Has(key(Service.ObjectMeta))
}

func (s serviceSet) Equal(
	ServiceSet ServiceSet,
) bool {
	return s.set.Equal(ServiceSet.Keys())
}

func (s serviceSet) Delete(Service *Service) {
	key := key(Service.ObjectMeta)
	delete(s.mapping, key)
	s.set.Delete(key)
}

func (s serviceSet) Union(set ServiceSet) ServiceSet {
	return NewServiceSet(append(s.List(), set.List()...)...)
}

func (s serviceSet) Difference(set ServiceSet) ServiceSet {
	newSet := s.set.Difference(set.Keys())
	var newServices []*Service
	for key, _ := range newSet {
		val, _ := s.mapping[key]
		newServices = append(newServices, val)
	}
	return NewServiceSet(newServices...)
}

func (s serviceSet) Intersection(set ServiceSet) ServiceSet {
	newSet := s.set.Intersection(set.Keys())
	var newServices []*Service
	for key, _ := range newSet {
		val, _ := s.mapping[key]
		newServices = append(newServices, val)
	}
	return NewServiceSet(newServices...)
}

type PodSet interface {
	Keys() sets.String
	List() []*Pod
	Map() map[string]*Pod
	Insert(pod ...*Pod)
	Equal(podSet PodSet) bool
	Has(pod *Pod) bool
	Delete(pod *Pod)
	Union(set PodSet) PodSet
	Difference(set PodSet) PodSet
	Intersection(set PodSet) PodSet
}

type podSet struct {
	set     sets.String
	mapping map[string]*Pod
}

func NewPodSet(Pods ...*Pod) PodSet {
	set := sets.NewString()
	mapping := map[string]*Pod{}
	for _, Pod := range Pods {
		key := key(Pod.ObjectMeta)
		set.Insert(key)
		mapping[key] = Pod
	}
	return &podSet{set: set, mapping: mapping}
}

func (s podSet) Keys() sets.String {
	return sets.NewString(s.set.List()...)
}

func (s podSet) List() []*Pod {
	var Pods []*Pod
	for _, key := range s.set.List() {
		Pods = append(Pods, s.mapping[key])
	}
	return Pods
}

func (s podSet) Map() map[string]*Pod {
	newMap := map[string]*Pod{}
	for k, v := range s.mapping {
		newMap[k] = v
	}
	return newMap
}

func (s podSet) Insert(
	Pods ...*Pod,
) {
	for _, Pod := range Pods {
		key := key(Pod.ObjectMeta)
		s.mapping[key] = Pod
		s.set.Insert(key)
	}
}

func (s podSet) Has(Pod *Pod) bool {
	return s.set.Has(key(Pod.ObjectMeta))
}

func (s podSet) Equal(
	PodSet PodSet,
) bool {
	return s.set.Equal(PodSet.Keys())
}

func (s podSet) Delete(Pod *Pod) {
	key := key(Pod.ObjectMeta)
	delete(s.mapping, key)
	s.set.Delete(key)
}

func (s podSet) Union(set PodSet) PodSet {
	return NewPodSet(append(s.List(), set.List()...)...)
}

func (s podSet) Difference(set PodSet) PodSet {
	newSet := s.set.Difference(set.Keys())
	var newPods []*Pod
	for key, _ := range newSet {
		val, _ := s.mapping[key]
		newPods = append(newPods, val)
	}
	return NewPodSet(newPods...)
}

func (s podSet) Intersection(set PodSet) PodSet {
	newSet := s.set.Intersection(set.Keys())
	var newPods []*Pod
	for key, _ := range newSet {
		val, _ := s.mapping[key]
		newPods = append(newPods, val)
	}
	return NewPodSet(newPods...)
}
