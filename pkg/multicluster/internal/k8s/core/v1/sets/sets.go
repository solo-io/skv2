// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	v1 "k8s.io/api/core/v1"

	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type SecretSet interface {
	Keys() sets.String
	List() []*v1.Secret
	Map() map[string]*v1.Secret
	Insert(secret ...*v1.Secret)
	Equal(secretSet SecretSet) bool
	Has(secret *v1.Secret) bool
	Delete(secret *v1.Secret)
	Union(set SecretSet) SecretSet
	Difference(set SecretSet) SecretSet
	Intersection(set SecretSet) SecretSet
	Find(id ezkube.ResourceId) (*v1.Secret, error)
}

func makeGenericSecretSet(secretList []*v1.Secret) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range secretList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type secretSet struct {
	set sksets.ResourceSet
}

func NewSecretSet(secretList ...*v1.Secret) SecretSet {
	return &secretSet{set: makeGenericSecretSet(secretList)}
}

func (s secretSet) Keys() sets.String {
	return s.set.Keys()
}

func (s secretSet) List() []*v1.Secret {
	var secretList []*v1.Secret
	for _, obj := range s.set.List() {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return secretList
}

func (s secretSet) Map() map[string]*v1.Secret {
	newMap := map[string]*v1.Secret{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Secret)
	}
	return newMap
}

func (s secretSet) Insert(
	secretList ...*v1.Secret,
) {
	for _, obj := range secretList {
		s.set.Insert(obj)
	}
}

func (s secretSet) Has(secret *v1.Secret) bool {
	return s.set.Has(secret)
}

func (s secretSet) Equal(
	secretSet SecretSet,
) bool {
	return s.set.Equal(makeGenericSecretSet(secretSet.List()))
}

func (s secretSet) Delete(Secret *v1.Secret) {
	s.set.Delete(Secret)
}

func (s secretSet) Union(set SecretSet) SecretSet {
	return NewSecretSet(append(s.List(), set.List()...)...)
}

func (s secretSet) Difference(set SecretSet) SecretSet {
	newSet := s.set.Difference(makeGenericSecretSet(set.List()))
	return secretSet{set: newSet}
}

func (s secretSet) Intersection(set SecretSet) SecretSet {
	newSet := s.set.Intersection(makeGenericSecretSet(set.List()))
	var secretList []*v1.Secret
	for _, obj := range newSet.List() {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return NewSecretSet(secretList...)
}

func (s secretSet) Find(id ezkube.ResourceId) (*v1.Secret, error) {
	obj, err := s.set.Find(&v1.Secret{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Secret), nil
}

type ServiceAccountSet interface {
	Keys() sets.String
	List() []*v1.ServiceAccount
	Map() map[string]*v1.ServiceAccount
	Insert(serviceAccount ...*v1.ServiceAccount)
	Equal(serviceAccountSet ServiceAccountSet) bool
	Has(serviceAccount *v1.ServiceAccount) bool
	Delete(serviceAccount *v1.ServiceAccount)
	Union(set ServiceAccountSet) ServiceAccountSet
	Difference(set ServiceAccountSet) ServiceAccountSet
	Intersection(set ServiceAccountSet) ServiceAccountSet
	Find(id ezkube.ResourceId) (*v1.ServiceAccount, error)
}

func makeGenericServiceAccountSet(serviceAccountList []*v1.ServiceAccount) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range serviceAccountList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceAccountSet struct {
	set sksets.ResourceSet
}

func NewServiceAccountSet(serviceAccountList ...*v1.ServiceAccount) ServiceAccountSet {
	return &serviceAccountSet{set: makeGenericServiceAccountSet(serviceAccountList)}
}

func (s serviceAccountSet) Keys() sets.String {
	return s.set.Keys()
}

func (s serviceAccountSet) List() []*v1.ServiceAccount {
	var serviceAccountList []*v1.ServiceAccount
	for _, obj := range s.set.List() {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return serviceAccountList
}

func (s serviceAccountSet) Map() map[string]*v1.ServiceAccount {
	newMap := map[string]*v1.ServiceAccount{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.ServiceAccount)
	}
	return newMap
}

func (s serviceAccountSet) Insert(
	serviceAccountList ...*v1.ServiceAccount,
) {
	for _, obj := range serviceAccountList {
		s.set.Insert(obj)
	}
}

func (s serviceAccountSet) Has(serviceAccount *v1.ServiceAccount) bool {
	return s.set.Has(serviceAccount)
}

func (s serviceAccountSet) Equal(
	serviceAccountSet ServiceAccountSet,
) bool {
	return s.set.Equal(makeGenericServiceAccountSet(serviceAccountSet.List()))
}

func (s serviceAccountSet) Delete(ServiceAccount *v1.ServiceAccount) {
	s.set.Delete(ServiceAccount)
}

func (s serviceAccountSet) Union(set ServiceAccountSet) ServiceAccountSet {
	return NewServiceAccountSet(append(s.List(), set.List()...)...)
}

func (s serviceAccountSet) Difference(set ServiceAccountSet) ServiceAccountSet {
	newSet := s.set.Difference(makeGenericServiceAccountSet(set.List()))
	return serviceAccountSet{set: newSet}
}

func (s serviceAccountSet) Intersection(set ServiceAccountSet) ServiceAccountSet {
	newSet := s.set.Intersection(makeGenericServiceAccountSet(set.List()))
	var serviceAccountList []*v1.ServiceAccount
	for _, obj := range newSet.List() {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return NewServiceAccountSet(serviceAccountList...)
}

func (s serviceAccountSet) Find(id ezkube.ResourceId) (*v1.ServiceAccount, error) {
	obj, err := s.set.Find(&v1.ServiceAccount{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.ServiceAccount), nil
}

type NamespaceSet interface {
	Keys() sets.String
	List() []*v1.Namespace
	Map() map[string]*v1.Namespace
	Insert(namespace ...*v1.Namespace)
	Equal(namespaceSet NamespaceSet) bool
	Has(namespace *v1.Namespace) bool
	Delete(namespace *v1.Namespace)
	Union(set NamespaceSet) NamespaceSet
	Difference(set NamespaceSet) NamespaceSet
	Intersection(set NamespaceSet) NamespaceSet
	Find(id ezkube.ResourceId) (*v1.Namespace, error)
}

func makeGenericNamespaceSet(namespaceList []*v1.Namespace) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range namespaceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type namespaceSet struct {
	set sksets.ResourceSet
}

func NewNamespaceSet(namespaceList ...*v1.Namespace) NamespaceSet {
	return &namespaceSet{set: makeGenericNamespaceSet(namespaceList)}
}

func (s namespaceSet) Keys() sets.String {
	return s.set.Keys()
}

func (s namespaceSet) List() []*v1.Namespace {
	var namespaceList []*v1.Namespace
	for _, obj := range s.set.List() {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return namespaceList
}

func (s namespaceSet) Map() map[string]*v1.Namespace {
	newMap := map[string]*v1.Namespace{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Namespace)
	}
	return newMap
}

func (s namespaceSet) Insert(
	namespaceList ...*v1.Namespace,
) {
	for _, obj := range namespaceList {
		s.set.Insert(obj)
	}
}

func (s namespaceSet) Has(namespace *v1.Namespace) bool {
	return s.set.Has(namespace)
}

func (s namespaceSet) Equal(
	namespaceSet NamespaceSet,
) bool {
	return s.set.Equal(makeGenericNamespaceSet(namespaceSet.List()))
}

func (s namespaceSet) Delete(Namespace *v1.Namespace) {
	s.set.Delete(Namespace)
}

func (s namespaceSet) Union(set NamespaceSet) NamespaceSet {
	return NewNamespaceSet(append(s.List(), set.List()...)...)
}

func (s namespaceSet) Difference(set NamespaceSet) NamespaceSet {
	newSet := s.set.Difference(makeGenericNamespaceSet(set.List()))
	return namespaceSet{set: newSet}
}

func (s namespaceSet) Intersection(set NamespaceSet) NamespaceSet {
	newSet := s.set.Intersection(makeGenericNamespaceSet(set.List()))
	var namespaceList []*v1.Namespace
	for _, obj := range newSet.List() {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return NewNamespaceSet(namespaceList...)
}

func (s namespaceSet) Find(id ezkube.ResourceId) (*v1.Namespace, error) {
	obj, err := s.set.Find(&v1.Namespace{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Namespace), nil
}
