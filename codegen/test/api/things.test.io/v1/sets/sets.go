// Code generated by skv2. DO NOT EDIT.

package v1sets

import (
	. "github.com/solo-io/skv2/codegen/test/api/things.test.io/v1"

	sksets "github.com/solo-io/skv2/pkg/contrib/sets"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/sets"
)

type PaintSet interface {
	Keys() sets.String
	List() []*Paint
	Map() map[string]*Paint
	Insert(paint ...*Paint)
	Equal(paintSet PaintSet) bool
	Has(paint *Paint) bool
	Delete(paint *Paint)
	Union(set PaintSet) PaintSet
	Difference(set PaintSet) PaintSet
	Intersection(set PaintSet) PaintSet
}

func makeGenericPaintSet(paintList []*Paint) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range paintList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type paintSet struct {
	set sksets.ResourceSet
}

func NewPaintSet(paintList ...*Paint) PaintSet {
	return &paintSet{set: makeGenericPaintSet(paintList)}
}

func (s paintSet) Keys() sets.String {
	return s.set.Keys()
}

func (s paintSet) List() []*Paint {
	var paintList []*Paint
	for _, obj := range s.set.List() {
		paintList = append(paintList, obj.(*Paint))
	}
	return paintList
}

func (s paintSet) Map() map[string]*Paint {
	newMap := map[string]*Paint{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*Paint)
	}
	return newMap
}

func (s paintSet) Insert(
	paintList ...*Paint,
) {
	for _, obj := range paintList {
		s.set.Insert(obj)
	}
}

func (s paintSet) Has(paint *Paint) bool {
	return s.set.Has(paint)
}

func (s paintSet) Equal(
	paintSet PaintSet,
) bool {
	return s.set.Equal(makeGenericPaintSet(paintSet.List()))
}

func (s paintSet) Delete(Paint *Paint) {
	s.set.Delete(Paint)
}

func (s paintSet) Union(set PaintSet) PaintSet {
	return NewPaintSet(append(s.List(), set.List()...)...)
}

func (s paintSet) Difference(set PaintSet) PaintSet {
	newSet := s.set.Difference(makeGenericPaintSet(set.List()))
	return paintSet{set: newSet}
}

func (s paintSet) Intersection(set PaintSet) PaintSet {
	newSet := s.set.Intersection(makeGenericPaintSet(set.List()))
	var paintList []*Paint
	for _, obj := range newSet.List() {
		paintList = append(paintList, obj.(*Paint))
	}
	return NewPaintSet(paintList...)
}

type ClusterResourceSet interface {
	Keys() sets.String
	List() []*ClusterResource
	Map() map[string]*ClusterResource
	Insert(clusterResource ...*ClusterResource)
	Equal(clusterResourceSet ClusterResourceSet) bool
	Has(clusterResource *ClusterResource) bool
	Delete(clusterResource *ClusterResource)
	Union(set ClusterResourceSet) ClusterResourceSet
	Difference(set ClusterResourceSet) ClusterResourceSet
	Intersection(set ClusterResourceSet) ClusterResourceSet
}

func makeGenericClusterResourceSet(clusterResourceList []*ClusterResource) sksets.ResourceSet {
	var genericResources []metav1.Object
	for _, obj := range clusterResourceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type clusterResourceSet struct {
	set sksets.ResourceSet
}

func NewClusterResourceSet(clusterResourceList ...*ClusterResource) ClusterResourceSet {
	return &clusterResourceSet{set: makeGenericClusterResourceSet(clusterResourceList)}
}

func (s clusterResourceSet) Keys() sets.String {
	return s.set.Keys()
}

func (s clusterResourceSet) List() []*ClusterResource {
	var clusterResourceList []*ClusterResource
	for _, obj := range s.set.List() {
		clusterResourceList = append(clusterResourceList, obj.(*ClusterResource))
	}
	return clusterResourceList
}

func (s clusterResourceSet) Map() map[string]*ClusterResource {
	newMap := map[string]*ClusterResource{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*ClusterResource)
	}
	return newMap
}

func (s clusterResourceSet) Insert(
	clusterResourceList ...*ClusterResource,
) {
	for _, obj := range clusterResourceList {
		s.set.Insert(obj)
	}
}

func (s clusterResourceSet) Has(clusterResource *ClusterResource) bool {
	return s.set.Has(clusterResource)
}

func (s clusterResourceSet) Equal(
	clusterResourceSet ClusterResourceSet,
) bool {
	return s.set.Equal(makeGenericClusterResourceSet(clusterResourceSet.List()))
}

func (s clusterResourceSet) Delete(ClusterResource *ClusterResource) {
	s.set.Delete(ClusterResource)
}

func (s clusterResourceSet) Union(set ClusterResourceSet) ClusterResourceSet {
	return NewClusterResourceSet(append(s.List(), set.List()...)...)
}

func (s clusterResourceSet) Difference(set ClusterResourceSet) ClusterResourceSet {
	newSet := s.set.Difference(makeGenericClusterResourceSet(set.List()))
	return clusterResourceSet{set: newSet}
}

func (s clusterResourceSet) Intersection(set ClusterResourceSet) ClusterResourceSet {
	newSet := s.set.Intersection(makeGenericClusterResourceSet(set.List()))
	var clusterResourceList []*ClusterResource
	for _, obj := range newSet.List() {
		clusterResourceList = append(clusterResourceList, obj.(*ClusterResource))
	}
	return NewClusterResourceSet(clusterResourceList...)
}
