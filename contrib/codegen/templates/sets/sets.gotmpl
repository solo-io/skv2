package {{.Version}}sets

import (
    {{- if $.CustomTypesImportPath }}

    . "{{ $.CustomTypesImportPath }}"
    {{- else}}

    . "{{ group_import_path $ }}"
    {{- end}}

    sksets "github.com/solo-io/skv2/contrib/pkg/sets"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/util/sets"
)

{{- range $resource := $.Resources }}

{{- $kindLowerCamel := lower_camel $resource.Kind }}

type {{ $resource.Kind }}Set interface {
    Keys() sets.String
    List() []*{{ $resource.Kind }}
    Map() map[string]*{{ $resource.Kind }}
    Insert({{ $kindLowerCamel }} ...*{{ $resource.Kind }})
    Equal({{ $kindLowerCamel }}Set {{ $resource.Kind }}Set) bool
    Has({{ $kindLowerCamel }} *{{ $resource.Kind }}) bool
    Delete({{ $kindLowerCamel }} *{{ $resource.Kind }})
    Union(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set
    Difference(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set
    Intersection(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set
}

func makeGeneric{{ $resource.Kind }}Set({{ $kindLowerCamel }}List []*{{ $resource.Kind }}) sksets.ResourceSet {
    var genericResources []metav1.Object
    for _, obj := range {{ $kindLowerCamel }}List {
        genericResources = append(genericResources, obj)
    }
    return sksets.NewResourceSet(genericResources...)
}

type {{ $kindLowerCamel }}Set struct {
    set sksets.ResourceSet
}

func New{{ $resource.Kind }}Set({{ $kindLowerCamel }}List ...*{{ $resource.Kind }}) {{ $resource.Kind }}Set {
    return &{{ $kindLowerCamel }}Set{set: makeGeneric{{ $resource.Kind }}Set({{ $kindLowerCamel }}List)}
}

func (s {{ $kindLowerCamel }}Set) Keys() sets.String {
    return s.set.Keys()
}

func (s {{ $kindLowerCamel }}Set) List() []*{{ $resource.Kind }} {
    var {{ $kindLowerCamel }}List []*{{ $resource.Kind }}
    for _, obj := range s.set.List() {
        {{ $kindLowerCamel }}List = append({{ $kindLowerCamel }}List, obj.(*{{ $resource.Kind }}))
    }
    return {{ $kindLowerCamel }}List
}

func (s {{ $kindLowerCamel }}Set) Map() map[string]*{{ $resource.Kind }} {
    newMap := map[string]*{{ $resource.Kind }}{}
    for k, v := range s.set.Map() {
        newMap[k] = v.(*{{ $resource.Kind }})
    }
    return newMap
}

func (s {{ $kindLowerCamel }}Set) Insert(
        {{ $kindLowerCamel }}List ...*{{ $resource.Kind }},
) {
    for _, obj := range {{ $kindLowerCamel }}List {
        s.set.Insert(obj)
    }
}

func (s {{ $kindLowerCamel }}Set) Has({{ $kindLowerCamel }} *{{ $resource.Kind }}) bool {
    return s.set.Has({{ $kindLowerCamel }})
}

func (s {{ $kindLowerCamel }}Set) Equal(
        {{ $kindLowerCamel }}Set {{ $resource.Kind }}Set,
) bool {
    return s.set.Equal(makeGeneric{{ $resource.Kind }}Set({{ $kindLowerCamel }}Set.List()))
}

func (s {{ $kindLowerCamel }}Set) Delete({{ $resource.Kind }} *{{ $resource.Kind }}) {
    s.set.Delete({{ $resource.Kind }})
}

func (s {{ $kindLowerCamel }}Set) Union(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set {
    return New{{ $resource.Kind }}Set(append(s.List(), set.List()...)...)
}

func (s {{ $kindLowerCamel }}Set) Difference(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set {
    newSet := s.set.Difference(makeGeneric{{ $resource.Kind }}Set(set.List()))
    return {{ $kindLowerCamel }}Set{set: newSet}
}

func (s {{ $kindLowerCamel }}Set) Intersection(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set {
    newSet := s.set.Intersection(makeGeneric{{ $resource.Kind }}Set(set.List()))
    var {{ $kindLowerCamel }}List []*{{ $resource.Kind }}
    for _, obj := range newSet.List() {
        {{ $kindLowerCamel }}List = append({{ $kindLowerCamel }}List, obj.(*{{ $resource.Kind }}))
    }
    return New{{ $resource.Kind }}Set({{ $kindLowerCamel }}List...)
}

{{- end }}
