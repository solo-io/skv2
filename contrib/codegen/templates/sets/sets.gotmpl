package {{.Version}}sets

{{ $import_prefix := group_import_name $ }}

import (
    {{ $import_prefix }} "{{ group_import_path $ }}"

    sksets "github.com/solo-io/skv2/contrib/pkg/sets"
    "github.com/solo-io/skv2/pkg/ezkube"
    "k8s.io/apimachinery/pkg/util/sets"
)

{{- range $resource := $.Resources }}

{{- $kindLowerCamel := lower_camel $resource.Kind }}

type {{ $resource.Kind }}Set interface {
    Keys() sets.String
    List() []*{{ $import_prefix }}.{{ $resource.Kind }}
    Map() map[string]*{{ $import_prefix }}.{{ $resource.Kind }}
    Insert({{ $kindLowerCamel }} ...*{{ $import_prefix }}.{{ $resource.Kind }})
    Equal({{ $kindLowerCamel }}Set {{ $resource.Kind }}Set) bool
    Has({{ $kindLowerCamel }} *{{ $import_prefix }}.{{ $resource.Kind }}) bool
    Delete({{ $kindLowerCamel }} *{{ $import_prefix }}.{{ $resource.Kind }})
    Union(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set
    Difference(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set
    Intersection(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set
    Find(id ezkube.ResourceId) (*{{ $import_prefix }}.{{ $resource.Kind }}, error)
    Length() int
}

func makeGeneric{{ $resource.Kind }}Set({{ $kindLowerCamel }}List []*{{ $import_prefix }}.{{ $resource.Kind }}) sksets.ResourceSet {
    var genericResources []ezkube.ResourceId
    for _, obj := range {{ $kindLowerCamel }}List {
        genericResources = append(genericResources, obj)
    }
    return sksets.NewResourceSet(genericResources...)
}

type {{ $kindLowerCamel }}Set struct {
    set sksets.ResourceSet
}

func New{{ $resource.Kind }}Set({{ $kindLowerCamel }}List ...*{{ $import_prefix }}.{{ $resource.Kind }}) {{ $resource.Kind }}Set {
    return &{{ $kindLowerCamel }}Set{set: makeGeneric{{ $resource.Kind }}Set({{ $kindLowerCamel }}List)}
}

func New{{ $resource.Kind }}SetFromList({{ $kindLowerCamel }}List *{{ $import_prefix }}.{{ $resource.Kind }}List) {{ $resource.Kind }}Set {
    list := make([]*{{ $import_prefix }}.{{ $resource.Kind }}, 0, len({{ $kindLowerCamel }}List.Items))
    for idx := range {{ $kindLowerCamel }}List.Items {
        list = append(list, &{{ $kindLowerCamel }}List.Items[idx])
    }
    return &{{ $kindLowerCamel }}Set{set: makeGeneric{{ $resource.Kind }}Set(list)}
}

func (s *{{ $kindLowerCamel }}Set) Keys() sets.String {
    return s.set.Keys()
}

func (s *{{ $kindLowerCamel }}Set) List() []*{{ $import_prefix }}.{{ $resource.Kind }} {
    var {{ $kindLowerCamel }}List []*{{ $import_prefix }}.{{ $resource.Kind }}
    for _, obj := range s.set.List() {
        {{ $kindLowerCamel }}List = append({{ $kindLowerCamel }}List, obj.(*{{ $import_prefix }}.{{ $resource.Kind }}))
    }
    return {{ $kindLowerCamel }}List
}

func (s *{{ $kindLowerCamel }}Set) Map() map[string]*{{ $import_prefix }}.{{ $resource.Kind }} {
    newMap := map[string]*{{ $import_prefix }}.{{ $resource.Kind }}{}
    for k, v := range s.set.Map() {
        newMap[k] = v.(*{{ $import_prefix }}.{{ $resource.Kind }})
    }
    return newMap
}

func (s *{{ $kindLowerCamel }}Set) Insert(
        {{ $kindLowerCamel }}List ...*{{ $import_prefix }}.{{ $resource.Kind }},
) {
    for _, obj := range {{ $kindLowerCamel }}List {
        s.set.Insert(obj)
    }
}

func (s *{{ $kindLowerCamel }}Set) Has({{ $kindLowerCamel }} *{{ $import_prefix }}.{{ $resource.Kind }}) bool {
    return s.set.Has({{ $kindLowerCamel }})
}

func (s *{{ $kindLowerCamel }}Set) Equal(
        {{ $kindLowerCamel }}Set {{ $resource.Kind }}Set,
) bool {
    return s.set.Equal(makeGeneric{{ $resource.Kind }}Set({{ $kindLowerCamel }}Set.List()))
}

func (s *{{ $kindLowerCamel }}Set) Delete({{ $resource.Kind }} *{{ $import_prefix }}.{{ $resource.Kind }}) {
    s.set.Delete({{ $resource.Kind }})
}

func (s *{{ $kindLowerCamel }}Set) Union(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set {
    return New{{ $resource.Kind }}Set(append(s.List(), set.List()...)...)
}

func (s *{{ $kindLowerCamel }}Set) Difference(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set {
    newSet := s.set.Difference(makeGeneric{{ $resource.Kind }}Set(set.List()))
    return &{{ $kindLowerCamel }}Set{set: newSet}
}

func (s *{{ $kindLowerCamel }}Set) Intersection(set {{ $resource.Kind }}Set) {{ $resource.Kind }}Set {
    newSet := s.set.Intersection(makeGeneric{{ $resource.Kind }}Set(set.List()))
    var {{ $kindLowerCamel }}List []*{{ $import_prefix }}.{{ $resource.Kind }}
    for _, obj := range newSet.List() {
        {{ $kindLowerCamel }}List = append({{ $kindLowerCamel }}List, obj.(*{{ $import_prefix }}.{{ $resource.Kind }}))
    }
    return New{{ $resource.Kind }}Set({{ $kindLowerCamel }}List...)
}


func (s *{{ $kindLowerCamel }}Set) Find(id ezkube.ResourceId) (*{{ $import_prefix }}.{{ $resource.Kind }}, error) {
	obj, err := s.set.Find(&{{ $import_prefix }}.{{ $resource.Kind }}{}, id)
	if err != nil {
		return nil, err
    }

    return obj.(*{{ $import_prefix }}.{{ $resource.Kind }}), nil
}

func (s *{{ $kindLowerCamel }}Set) Length() int {
    return s.set.Length()
}

{{- end }}
